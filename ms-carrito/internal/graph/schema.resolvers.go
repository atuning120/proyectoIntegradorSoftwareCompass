package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"fmt"
	"log"

	"github.com/proyectoIntegradorSoftware/ms-carrito/internal/consumer"
	connection "github.com/proyectoIntegradorSoftware/ms-carrito/internal/database"
	"github.com/proyectoIntegradorSoftware/ms-carrito/internal/graph/model"
	"github.com/proyectoIntegradorSoftware/ms-carrito/internal/repository"
	"github.com/proyectoIntegradorSoftware/ms-carrito/internal/services"
)

// AgregarProducto is the resolver for the AgregarProducto field.
func (r *mutationResolver) AgregarProducto(ctx context.Context, input model.AgregarProductoInput) (*model.Carrito, error) {
	consumer.ValidacionUsuarioRPC(input.IDUsuario)
	consumer.ValidacionProductoRPC(input.IDProducto)

	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
	}
	defer func() {
		if err := client.Disconnect(context.TODO()); err != nil {
			log.Fatalf("Error desconectando MongoDB: %v", err)
		}
	}()

	db := client.Database("Carrito")
	carritorepo := repository.NewHisotialRepositoryImpl(db)
	carritoService := services.NewServicioHistorialImpl(carritorepo)

	isAdded, err := carritoService.AnadirProduct(ctx, input.IDUsuario, input.IDProducto)
	if err != nil {
		return nil, fmt.Errorf("error al agregar producto al carrito: %v", err)
	}

	if !isAdded {
		return nil, fmt.Errorf("el producto ya está en el carrito")
	}

	carritoActualizado, err := carritorepo.FindById(ctx, input.IDUsuario)
	if err != nil {
		return nil, fmt.Errorf("error al obtener el carrito actualizado: %v", err)
	}

	return &model.Carrito{
		ID:          carritoActualizado.ID.Hex(),
		IDUsuario:   carritoActualizado.IDUsuario.Hex(),
		IDProductos: consumer.ConvertObjectIDsToStrings(carritoActualizado.IDProductos),
	}, nil
}

// EliminarProducto is the resolver for the EliminarProducto field.
func (r *mutationResolver) EliminarProducto(ctx context.Context, input model.EliminarProductoInput) (*model.Carrito, error) {
	consumer.ValidacionUsuarioRPC(input.IDUsuario)
	consumer.ValidacionProductoRPC(input.IDProducto)

	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
	}
	defer func() {
		if err := client.Disconnect(context.TODO()); err != nil {
			log.Fatalf("Error desconectando MongoDB: %v", err)
		}
	}()

	db := client.Database("Carrito")
	carritorepo := repository.NewHisotialRepositoryImpl(db)
	carritoService := services.NewServicioHistorialImpl(carritorepo)

	isAdded, err := carritoService.EliminarProducto(ctx, input.IDUsuario, input.IDProducto)
	if err != nil {
		return nil, fmt.Errorf("error al agregar producto al carrito: %v", err)
	}

	if !isAdded {
		return nil, fmt.Errorf("el producto ya está en el carrito")
	}

	carritoActualizado, err := carritorepo.FindById(ctx, input.IDUsuario)
	if err != nil {
		return nil, fmt.Errorf("error al obtener el carrito actualizado: %v", err)
	}

	return &model.Carrito{
		ID:          carritoActualizado.ID.Hex(),
		IDUsuario:   carritoActualizado.IDUsuario.Hex(),
		IDProductos: consumer.ConvertObjectIDsToStrings(carritoActualizado.IDProductos),
	}, nil
}

// VaciarCarrito is the resolver for the VaciarCarrito field.
func (r *mutationResolver) VaciarCarrito(ctx context.Context, idUsuario string) (*model.Carrito, error) {
	consumer.ValidacionUsuarioRPC(idUsuario)
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
	}
	defer func() {
		if err := client.Disconnect(context.TODO()); err != nil {
			log.Fatalf("Error desconectando MongoDB: %v", err)
		}
	}()
	db := client.Database("Carrito")
	carrtiorep := repository.NewHisotialRepositoryImpl(db)
	carritoserv := services.NewServicioHistorialImpl(carrtiorep)

	isDeleted, err := carritoserv.EliminarProductos(ctx, idUsuario)
	if err != nil {
		return nil, fmt.Errorf("error al vaciar el carrito: %v", err)
	}
	if !isDeleted {
		return nil, fmt.Errorf("el carrito ya está vacío")
	}
	carritoActualizado, err := carrtiorep.FindById(ctx, idUsuario)
	if err != nil {
		return nil, fmt.Errorf("error al obtener el carrito actualizado: %v", err)
	}

	return &model.Carrito{
		ID:          carritoActualizado.ID.Hex(),
		IDUsuario:   carritoActualizado.IDUsuario.Hex(),
		IDProductos: consumer.ConvertObjectIDsToStrings(carritoActualizado.IDProductos),
	}, nil
}

// VaciarProductosComprados is the resolver for the VaciarProductosComprados field.
func (r *mutationResolver) VaciarProductosComprados(ctx context.Context, input *model.VaciarCarritoComprado) (*model.Carrito, error) {
	consumer.ValidacionUsuarioRPC(input.IDUsuario)
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
	}
	defer func() {
		if err := client.Disconnect(context.TODO()); err != nil {
			log.Fatalf("Error desconectando MongoDB: %v", err)
		}
	}()
	db := client.Database("Carrito")
	carrtiorep := repository.NewHisotialRepositoryImpl(db)
	carritoserv := services.NewServicioHistorialImpl(carrtiorep)

	isDeleted, err := carritoserv.EliminarProductosComprados(ctx, input.IDUsuario, input.IDProductos)
	if err != nil {
		return nil, fmt.Errorf("error al vaciar el carrito: %v", err)
	}
	if !isDeleted {
		return nil, fmt.Errorf("el carrito ya está vacío")
	}
	carritoActualizado, err := carrtiorep.FindById(ctx, input.IDUsuario)
	if err != nil {
		return nil, fmt.Errorf("error al obtener el carrito actualizado: %v", err)
	}

	return &model.Carrito{
		ID:          carritoActualizado.ID.Hex(),
		IDUsuario:   carritoActualizado.IDUsuario.Hex(),
		IDProductos: consumer.ConvertObjectIDsToStrings(carritoActualizado.IDProductos),
	}, nil
}

// ObtenerCarritos is the resolver for the ObtenerCarritos field.
func (r *queryResolver) ObtenerCarritos(ctx context.Context) ([]*model.Carrito, error) {
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
	}
	defer func() {
		if err := client.Disconnect(context.TODO()); err != nil {
			log.Fatalf("Error desconectando MongoDB: %v", err)
		}
	}()

	db := client.Database("Carrito")
	carritorepo := repository.NewHisotialRepositoryImpl(db)

	carritos, err := carritorepo.FindAllCarritos(ctx)
	if err != nil {
		return nil, fmt.Errorf("error al obtener todos los carritos: %v", err)
	}

	// Convertir los carritos a un formato compatible con GraphQL
	var resultado []*model.Carrito
	for _, carrito := range carritos {
		resultado = append(resultado, &model.Carrito{
			ID:          carrito.ID.Hex(),
			IDUsuario:   carrito.IDUsuario.Hex(),
			IDProductos: consumer.ConvertObjectIDsToStrings(carrito.IDProductos),
		})
	}
	return resultado, nil
}

// ObtenerCarrito is the resolver for the ObtenerCarrito field.
func (r *queryResolver) ObtenerCarrito(ctx context.Context, id string) (*model.Carrito, error) {
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
	}
	defer func() {
		if err := client.Disconnect(context.TODO()); err != nil {
			log.Fatalf("Error desconectando MongoDB: %v", err)
		}
	}()

	db := client.Database("Carrito")
	carritorepo := repository.NewHisotialRepositoryImpl(db)

	carritoActualizado, err := carritorepo.FindById(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error al obtener el carrito actualizado: %v", err)
	}

	return &model.Carrito{
		ID:          carritoActualizado.ID.Hex(),
		IDUsuario:   carritoActualizado.IDUsuario.Hex(),
		IDProductos: consumer.ConvertObjectIDsToStrings(carritoActualizado.IDProductos),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
