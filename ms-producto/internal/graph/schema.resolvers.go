package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"

	crud "github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/CRUD"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/connection"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/consumer"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/graph/model"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/repository"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/service"
)

// Resolver de la Mutation crearCurso
func (r *mutationResolver) CrearCurso(ctx context.Context, input model.NewCurso) (*model.Curso, error) {
	// Obtener conexi贸n a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	// Crear un nuevo producto en la base de datos
	nuevoCurso := crud.Product{
		Nombre:      input.Nombre,
		Descripcion: input.Descripcion,
		Precio:      input.Precio,
		Imagen:      input.Imagen,
		Categoria:   input.Categoria,
		Nivel:       input.Nivel,
		Puntuacion:  input.Puntuacion,
	}

	err = crud.CreateProduct(client, nuevoCurso)
	if err != nil {
		return nil, fmt.Errorf("error al crear el curso: %v", err)
	}

	// Convertir a tipo GraphQL y retornar
	return &model.Curso{
		Nombre:      nuevoCurso.Nombre,
		Descripcion: nuevoCurso.Descripcion,
		Precio:      nuevoCurso.Precio,
		Imagen:      nuevoCurso.Imagen,
		Categoria:   nuevoCurso.Categoria,
		Nivel:       nuevoCurso.Nivel,
		Puntuacion:  nuevoCurso.Puntuacion,
	}, nil
}

// Cursos is the resolver for the cursos field.
func (r *queryResolver) Cursos(ctx context.Context) ([]*model.Curso, error) {
	// Obtener conexi贸n a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	// Obtener todos los productos (cursos) de la base de datos
	cursosDB, err := crud.GetAllCursos(client)
	if err != nil {
		return nil, err
	}

	// Convertir productos de la base de datos a tipo Curso de GraphQL
	var cursos []*model.Curso
	for _, cursoDB := range cursosDB {
		curso := &model.Curso{
			ID:          cursoDB.ID,
			Nombre:      cursoDB.Nombre,
			Descripcion: cursoDB.Descripcion,
			Precio:      cursoDB.Precio,
			Imagen:      cursoDB.Imagen,
			Categoria:   cursoDB.Categoria,
			Nivel:       cursoDB.Nivel,
			Puntuacion:  cursoDB.Puntuacion,
		}
		cursos = append(cursos, curso)
	}

	return cursos, nil
}

// Resolver de la Query topCursos
func (r *queryResolver) TopCursos(ctx context.Context) ([]*model.Curso, error) {
	// Obtener conexi贸n a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	// Obtener los 4 mejores cursos de la base de datos
	topCursosDB, err := crud.GetTopCursos(client)
	if err != nil {
		return nil, err
	}

	// Convertir productos de la base de datos a tipo Curso de GraphQL
	var topCursos []*model.Curso
	for _, cursoDB := range topCursosDB {
		curso := &model.Curso{
			ID:          cursoDB.ID,
			Nombre:      cursoDB.Nombre,
			Descripcion: cursoDB.Descripcion,
			Precio:      cursoDB.Precio,
			Imagen:      cursoDB.Imagen,
			Categoria:   cursoDB.Categoria,
			Nivel:       cursoDB.Nivel,
			Puntuacion:  cursoDB.Puntuacion,
		}
		topCursos = append(topCursos, curso)
	}

	return topCursos, nil
}

// CursosPorID is the resolver for the cursosPorId field.
func (r *queryResolver) CursosPorID(ctx context.Context, ids []string, userID string) ([]*model.Curso, error) {

	consumer.ValidacionUsuarioRPC(userID)
	for _, id := range ids {
		consumer.ValidacionProductoRPC(id)
	}

	// Obtener conexi贸n a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	db := client.Database("Producto")
	repo := repository.NewProductoRepositoryImpl(db)
	serv := service.NewProductoServiceImpl(repo)

	modelCursos, err := serv.BuscarCursos(ctx, ids)
	if err != nil {
		return nil, err
	}

	var cursos []*model.Curso
	for _, curso := range modelCursos {
		cursos = append(cursos, &model.Curso{
			ID:          curso.ID.Hex(),
			Nombre:      curso.Nombre,
			Descripcion: curso.Descripcion,
			Precio:      curso.Precio,
			Imagen:      curso.Imagen,
			Categoria:   curso.Categoria,
			Nivel:       curso.Nivel,
			Puntuacion:  curso.Puntuacion,
		})
	}

	return cursos, nil

}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
