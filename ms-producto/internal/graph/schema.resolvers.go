package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"

	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/connection"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/consumer"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/graph/model"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/models"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/repository"
	"github.com/atuning120/proyectoIntegradorSoftware/ms-producto/internal/service"
)

func (r *mutationResolver) CrearCurso(ctx context.Context, input model.NewCurso) (*model.Curso, error) {
	// Obtener conexión a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	// Crear el curso sin especificar el ID
	nuevoCurso := models.Product{
		Nombre:      input.Nombre,
		Descripcion: input.Descripcion,
		Precio:      input.Precio,
		Imagen:      input.Imagen,
		Categoria:   input.Categoria,
		Nivel:       input.Nivel,
		Puntuacion:  input.Puntuacion,
	}

	// Inicializar el repositorio y el servicio
	db := client.Database("Producto")
	repo := repository.NewProductoRepositoryImpl(db)
	serv := service.NewProductoServiceImpl(repo)

	// Llamar al servicio para crear el producto y obtener el ObjectID generado
	oid, err := serv.CrearProducto(ctx, nuevoCurso)
	if err != nil {
		return nil, err
	}

	// Asignar el ObjectID generado al campo ID de nuevoCurso
	nuevoCurso.ID = oid

	// Convertir el curso a tipo GraphQL y retornar con el ID generado
	return &model.Curso{
		ID:          nuevoCurso.ID.Hex(), // Convertir ObjectID a string
		Nombre:      nuevoCurso.Nombre,
		Descripcion: nuevoCurso.Descripcion,
		Precio:      nuevoCurso.Precio,
		Imagen:      nuevoCurso.Imagen,
		Categoria:   nuevoCurso.Categoria,
		Nivel:       nuevoCurso.Nivel,
		Puntuacion:  nuevoCurso.Puntuacion,
	}, nil
}

func (r *queryResolver) Cursos(ctx context.Context) ([]*model.Curso, error) {
	// Obtener conexión a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	// Inicializar el repositorio y servicio
	db := client.Database("Producto")
	repo := repository.NewProductoRepositoryImpl(db)
	serv := service.NewProductoServiceImpl(repo)

	// Llamar al servicio para obtener todos los cursos
	cursosDB, err := serv.GetAllCursos(ctx)
	if err != nil {
		return nil, err
	}

	// Convertir productos de la base de datos a tipo Curso de GraphQL
	var cursos []*model.Curso
	for _, cursoDB := range cursosDB {
		curso := &model.Curso{
			ID:          cursoDB.ID.Hex(), // Convertir ObjectID a string
			Nombre:      cursoDB.Nombre,
			Descripcion: cursoDB.Descripcion,
			Precio:      cursoDB.Precio,
			Imagen:      cursoDB.Imagen,
			Categoria:   cursoDB.Categoria,
			Nivel:       cursoDB.Nivel,
			Puntuacion:  cursoDB.Puntuacion,
		}
		cursos = append(cursos, curso)
	}

	return cursos, nil
}

// Resolver de la Query topCursos
func (r *queryResolver) TopCursos(ctx context.Context) ([]*model.Curso, error) {
	// Obtener conexión a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	// Inicializar el repositorio y servicio
	db := client.Database("Producto")
	repo := repository.NewProductoRepositoryImpl(db)
	serv := service.NewProductoServiceImpl(repo)

	// Llamar al servicio para obtener los 4 cursos con mayor puntuación
	topCursosDB, err := serv.GetTopCursos(ctx)
	if err != nil {
		return nil, err
	}

	// Convertir productos de la base de datos a tipo Curso de GraphQL
	var topCursos []*model.Curso
	for _, cursoDB := range topCursosDB {
		curso := &model.Curso{
			ID:          cursoDB.ID.Hex(), // Convertir ObjectID a string
			Nombre:      cursoDB.Nombre,
			Descripcion: cursoDB.Descripcion,
			Precio:      cursoDB.Precio,
			Imagen:      cursoDB.Imagen,
			Categoria:   cursoDB.Categoria,
			Nivel:       cursoDB.Nivel,
			Puntuacion:  cursoDB.Puntuacion,
		}
		topCursos = append(topCursos, curso)
	}

	return topCursos, nil
}

// CursosPorID is the resolver for the cursosPorId field.
func (r *queryResolver) CursosPorID(ctx context.Context, ids []string, userID string) ([]*model.Curso, error) {

	consumer.ValidacionUsuarioRPC(userID)
	for _, id := range ids {
		consumer.ValidacionProductoRPC(id)
	}

	// Obtener conexión a MongoDB
	client, err := connection.ConnectToMongoDB()
	if err != nil {
		return nil, fmt.Errorf("error conectando a la base de datos: %v", err)
	}

	db := client.Database("Producto")
	repo := repository.NewProductoRepositoryImpl(db)
	serv := service.NewProductoServiceImpl(repo)

	modelCursos, err := serv.BuscarCursos(ctx, ids)
	if err != nil {
		return nil, err
	}

	var cursos []*model.Curso
	for _, curso := range modelCursos {
		cursos = append(cursos, &model.Curso{
			ID:          curso.ID.Hex(),
			Nombre:      curso.Nombre,
			Descripcion: curso.Descripcion,
			Precio:      curso.Precio,
			Imagen:      curso.Imagen,
			Categoria:   curso.Categoria,
			Nivel:       curso.Nivel,
			Puntuacion:  curso.Puntuacion,
		})
	}

	return cursos, nil

}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
